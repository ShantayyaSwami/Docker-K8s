K8s is powerful tool however few challenges hampers its adoption
1. Deployment complexity: 
order of resource deployment (pod,ns,cm etc). due to dependency order deployment will fail
2. Application versioning and rollback :
rollback is difficult due to K8s not provide built-in mechanism for apps versioning
3. reusability and sharability:
Reusing configurations across different environments is difficult due to different env need diff config. 

Helm: 
Its a tool which manages the K8s based applications by providing standard approach as helm charts(tar -> collection of YAML files). its package manager for k8s.
Helm can:
1. install software
2. auto install software dependancies
3. Upgrade software
4. configure software deployments
5. fetch soft pkgs from soft repo called chart repo (chart museum)

		package manager		packages
system		apt			deb
		yum			rpm
Development	maven			jar/jav artifacts
		npm			node modules
		pip			python packages
K8s		helm			charts

example: 
system				K8s
apt install nginx		helm install <release-name> bitnam/nginx
apt uprade			helm upgrade <release-name> bitnam/nginx

why helm is popular:
1. Hiding complexity of running multiple YAML files to deploy apps. run single command that install all YAML files at once. 
2. one click install/upgrade/rollback apps
3. same charts reusable for multi env. 


why helm is not:
1. its not system package manager.
2. configuration management tool (ansible,shef,puppet etc)
3. K8s resource lifecycle controller 
4. version control system 


----Helm terminologies-------
Helm Client/Helm:
command line tool for developing charts,managing repo,releases and interfacing with helm library

Tiller:
Its a helm server. Interacts directly with K8s API server to install,upgrade,query and remove K8s resources. its installed in K8s cluster and runs as pod. 
Tiller is removed in Helm3.

chart:
A package of pre-configured K8s resources. its tar with collection of YAML files. 

Release:
Its an instance of chart running in K8s cluster. same chart can be deployed multiple times in multiple env. 

Repo:
place where charts resides and can be shared with others. 


---changes from Helm2 to Helm3------ 
1. Tiller removed in helm3   --> When Helm2 was developed K8s did not had RBAC so helm had to take care of auth part (who and what actions a user can perform in K8s cluster). with K8s 1.6 RBAC is enabled by default so there is no need for helm  to do the same job which can be done by K8s. 

2. Three way strategic merge patch --> In Helm2 patch would be generated by comparing old manifest with new one. if someone manually changed deployment,helm has no 
info regarding that and rollback would give erroneous result. 
in Helm3 patch is generated using old manifest,live state of cluster and new manifest.

3. secret as default storage driver ---> Helm2 uses ConfigMap to store release info. in Helm3 Secrets are used as default storage driver. 

4. JSON schema chart validation
5. Release name is now required  --> In Helm2 if no name was provided then release name would be generated. Helm3 will throw error if no name is provided. 
6. Helm 2, where external changes could lead to inconsistencies during rollbacks. but due to helm3 3 way strategic merge patch it will rollback successfully. 


--------chart meseum------- (https://artifactshub.io)
chart repo is location where packaged charts can be stored and shared. 
Official chart repo is maintained by K8s charts, but Helm also makes it easy to create and run your own chart repo. 

helm --help					--> shows command options

helm repo update
helm search repo mysql				--> searh mysql repo

helm repo remove <repo_name>			--> remove repo 

helm pull chartrepo/chartname			--> pull charts

Note: ChartMeseum is open source helm chart repo. https://chartmeseum.com 


--------------chart advance----------------
chart create example-chart				--> create chart template
1. helmignore: holds all files to ignore when packaging the chart.similar to gitignore. 
2. chart.yaml: Holds metadata about chart, such as chart name, version, maintainer info,search keyword etc. 
3. charts: dir which stores other charts that main chart depends on. 
4. Values.yaml: holds all the values to be injected into template. Templates are rendered into K8s manifest files. 
5. Values.schema.json: validates values.yaml file. removing any required fields will result in error as JSON schema validation fails. This check happens everytime we run helm install/upgrade/template
6. Templates: Holds the actual manifest to be deployed with chart. i.e deployment.yaml,service.yaml,config.yaml and secrets.yaml all in the templated format. this wil all get values from values.yaml file. 
7. LICENSE: a plaintext license for the chart
8. NOTES.txt file: prints on command line when the chart is installed. like help menu for clients.  
9. _helpers.tpl: handles templates
10. README.md: A readme file with information for users of the chart. 
11. requirements.yaml: A YAML file that lists the chart dependancies. 					--> removed and now dependancy mentioned in chart.yaml

---chart dir structure contains----
---1. charts					--> dir contain other charts for dependancy management. sub-charts with same template structure. 
---2. chart.yaml				--> contains metadata of chart like name of chart,version of chart,apps,dependancies,sources etc
---LICENSE
---README.md
---requirements.yaml
---3. templates					--> directory contains YAML files that define Kubernetes resources (such as deployments, services, etc.)
   |_____deployment.yaml
   |_______helpers.tpl
   |_____hra.yaml
   |____ingress.yaml
   |___NOTES.txt				
   |___serviceaccount.yaml
   |_____service.yaml
   |____tests
        |____test-connection.yaml

----values.schema.json
----4. Values.yaml				--> holds all the values to be injected into template. Templates are rendered into K8s manifest files. 

Note: From helm3 dependancies are moved to chart.yaml file. thus eliminating the need for requirements.yaml file. To download all the dependancies into chart directory
run "helm dependancy update". 

helm pull bitnami/mysql

---adding helm repo--
helm repo add bitnami https://charts.bitnami.com/bitnami
helm repo update
helm repo list
helm repo remove <remo_name> 

--searching for chart--												---setup order of deployment file
helm repo update													1. ns
helm search repo mysql													2. secret
															3. configMap
---check values for chart--												4. StorageClass --> PV --> PVC
helm show values bitnami/nginx  (before installation)									7. clusterRol,CusterRoleBinding,Role,RoleBindin
helm get values <release_name> (user supplied values shows before instalation)						11. service 	
															12. DaemonSet
---installing chart---													13. Pod
helm install bitnami/nginx --generate-name  or helm install <release-name> bitnami/nginx				14. ReplicationController
helm list		--> list all releases										15. ReplicaSet
helm status <release name> 												16. Deployment
helm uninstall <release-name> 												17. StatefulSet
															18. Job --> CronJob
other ways:														20. Ingress
1. chart repository													21. APIService
2. local chart archieve (helm install foo foo-0.1.1.tgz)
3. unpacked chart dir (helm install foo path/to/foo)
4. A full url (helm install foo url)

---changing defaut values with --set ----
helm install bitnami/nginx --set service.type=ClusterIP					--> use helm upgrade --install	 it will upgrade if existing else install
helm get values nginx

--changing the default values with custom values file---
helm show values bitnami/nginx > custom_value.yaml
helm install nginx bitnami/nginx -f custom_value.yaml

--upgrade chart---		--> update manifest file with any changes like image tags,replicas and upgrade the chart/release
helm upgrade <release-name> <chart>
helm upgrade demo-release helm-chart-demo-sample1

---check revision history---
helm history <release-name> 

--rolback to previous release---
helm rollback <release-name> <revision number> 


---create chart structure---
helm create test			--> creates chart dir structure
cd test and helm package		--> create chart package i.e tgz which can be used for installation 


----helm dependancy management----
dependancies can be dynamically linked using dependancies field in chart.yaml and dependancies can be pulled from url or repo name if already added through
helm repo add 

helm dependancy list <cart-name> 			--> list all dependancies of chart

Chart dependancies: conditions and Tags (both boolean values)
by default all dependancies are installed. Tags and conditions control loading of dependancies and are to be set in values.yaml file. 
Note: absence of condition has no effect. conditions always overrite tags. Multiple tags are injected as list. if one tag is true then dependancy is installed. (OR)
dependancy can be either chart-archive (.tgz file) or unpacked chart dir.

example: 
dependancies:
  - name: nginx
    version: 8.3.0  --> chart version 
    repository: <url> 
    condition: nginx.enabled
    tags:
    - front-end
    - subchart1

values.yaml
nginx:
  enabled: true
tags:
 front-end: true


-----------------render templates-----------------
Helm uses the Go templating engine by default and funtions from sprig lib. Templates are rendered by helm template engine in K8s manifest files at the client side before sending it to K8s API.  

Templates directory:
NOTES.txt: The "help text" for chart. this will be displayed to user when they run helm install
deployment.yaml: basic manifest to create K8s deployment
service.yaml: basic manifest to create service endpoint for your deployment.
_helpers.tpl: A place to template helpers that you can re-use throughout chart just like functions. 

--adding basic templating--
{{ .Values.image.name }}   
     |___.values indicates values.yaml file at the root then imaage and name inside values.yaml file 

Build-in Objects:
Release.Name: Name of release. not chart name
Release.Namespace: ns the chart was released to
chart.Name: name of chart
chart.Version: version of chart

{{ chart.Name }}-{{- Release.Name}}				--> - (hyphen) used to trim white spaces. white spaces are added if we use {{ }} so use - to remove 

--rendering charts---
you can render charts without actually installing them. useful to test chart templates. 
Two ways:
1. Rendering without release info {{ Release.Name }} won't evaluate
helm template <chart-dir> 						--> cannot replace any values that depends on release info + wont connect to API server for validation
2. Rendering with release info						--> connect to APi server for chart validation. 
helm install <chart-dir> --dry-run

----linting helm charts-----
used to see errors associated with helm charts
helm lint chartname

---values files---
The values for the templates can be supplied in one of 3 ways
1. values.yaml file inside of chart. 
2. custom values YAML file to be provided at command line with "helm install -f" command
3. Using --set flag

helm install my-wordpress bitnami/wordpress -f values-prod.yaml
helm install --values myvalues.yaml bitnami
helm install demo-sql stable/mysql --set db.name='test'

--mandatory/required values
image: "{{ .Values.image.name }}:{{ required "A valid .Values.image.tag is required" .Values.image.tag }}"			--> when required values are not set helm throws an error. 

--default values and pipelines
when values are not set in values.yaml then default values are used. 
replica: {{ default 1 .Values.replica | int }}


--template functions--
{{ .Values.app.url | quote }}			--> quote is function for "" (other avail fun like upper,lower,trunc etc)

index function is used to access array elements:
Values.yaml--> 
colors:							{{ index .Values.colors 0 }} 	--> to access blue
 - blue
 - red
 - green
image:							{{ (index .Values.image.lables 0).app }}	--> prints db
  labels:
   - app: db
   - env: prod
		

--template var---
Var is named ref to another object. it follows the form $name and use special assignment operator :=. used in conjunction "with" and "range".  there is global var $. points to root context. 

ex:
{{- $podname := "nginx" -}}
appVersion: v1
kind: pod
metadata: 
  name: {{ $podname }}-pod
spec: 


---if-else---
OR  {{- if or .Values.myapp.config.local .Values.myapp.config.nfs }}
     ... 
    {{- end }}

NOT {{- if not .Values.app.something }}
    ...
    {{ end }}

equal {{- if eq .Values.app.something .Values.app.somethingElse }}
      ...
      {{- end }}

not equal {{- if ne .Values.myapp.color "blue" }}
          ...
          {{- end }}


ex:
db_data:					--> Values.yaml
  env: prod
  db_user: admin
  db_table: "test-db"

apiVersion: v1						--> templates/dep.yaml
kind: pod
metadata:
  name: {{ Release.name }}-configmap
data:
  env: {{ .Values.db_data.env | default "dev" }}		--> .Values.db_data can be written once by setting scope using "with". no need to repeat scope
  db_user: {{ .Values.db_data.db_user | lower }}
  {{- if eq .Values.db_data.db_table "test-db" }}
  db: test-db
  {{ else }}
  db: prod-db
  {{- end }}


---range function---
{{ . }} -->  current element in iterator. 
ex: 
metadata:					--> templates/dep.yaml
  {{- if .Values.db_data }}
  annotations:
    {{- range $key, $value := .Values.db_data }}
    {{ $key }}: {{ $value | quote -}}
    {{- end }}
  {{- end}}


iterate over list:	
env:						--> templates/dep.yaml 
{{- range list "blue" "red" "green" }}
- name: {{ . | upper | printf "COLOR_%s" }}
  value: {{ . -}}
{{- end }}


---modify scope with---
"with" controls var scope and current scope be changed using it. 
ex: 
apiVersion: v1						--> templates/dep.yaml
kind: pod
metadata:
  name: {{ Release.name }}-configmap
data:
  {{- with .Values.db_data }} 
  end: {{ .env | default "dev" }}
  db_user: {{ .db_user | lower }}
  {{- if eq .db_table "test-db" }}
  db: test-db
  {{ else }}
  db: prod-db
  {{- end }}
  {{- end }}


---------------------Named templates----------------------------------
Named template/sub-template/embedded template is fragment of text that is declared(using define keyword) in one file (always named with _ like _helpers.tpl) and rendered into another template, usually in different file. 
invoked using template function or include function with scope. 
syntax: {{- define "mychart.subtemplate" }}					-> sub-templates created using define
        ...
        {{- end }}

{{ include "<sub-template-name>" <scope> }}
{{ template "<sub-template-name>" <scope> }}

ex: 
{{- define "mychart.labels" }}					--> templates/_helpers.tpl
lables:
  generator: helm
  date: {{ now | htmlDate }}
{{- end }}


apiVersion: v1
kind: pod
metadata:						output--> metadata:
  name: {{ .Release.Name }}-configmap					name: RELEASE-NAME-configmap
  {{- template "mychart.labels" }}					labels:
data: 									  generator: helm
									  date: 2023-12-09



using include:
ex: 
{{- define "mychart.app" }}
app_name: {{ .chart.name }}
app_version: {{ .chart.version }}
{{- end -}}

apiVersion: v1
kind: configMap
metadata: 
  name: {{ .Release.Name  }}-configmap
  lables:
  {{ include "mychart.app" . | indent 4 }}			--> . indicates root scope
	

Note: nindent used to provide number of indentation in next line. 
Helm preserves indentation with the template keyword and may require explicit indentation adjustments (using functions like nindent) when using the include keyword, not the other way around. 







